#+TITLE:AEON (Another Emacs Operating eNvironment)
#+AUTHOR:Joshua Suskalo
#+EMAIL:joshua@suskalo.org
#+LANGUAGE: en
#+STARTUP: align indent

* Introduction
:PROPERTIES:
:header-args: :noweb no-export :tangle no
:END:
AEON is a literate config for emacs, built around modularity and ease of use.
Besides some core functionality which is loaded in this file, all functionality
within AEON is built from modules.  Each module may provide configuration for a
programming language or software package for emacs, may provide a different way
of working with a certain type of file, or may have larger, far-reaching effects
like an =evil= module which would change the behavior of most other modules by
adding vim emulation and bindings.

We start with bootstrapping the package manager and some core emacs settings
which are used throughout the config, and then from there initialize the module
systems, before finally allowing user customizations to persist between runs of
emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  <<bootstrap-aeon>>
  <<bootstrap-module-loading>>
  <<load-emacs-custom-file>>
#+END_SRC


* Bootstrapping
:PROPERTIES:
:header-args: :noweb no-export :tangle no
:END:
In order to bootstrap AEON, we first have to change some default settings from
emacs which might get in our way, and then we initialize the core packages which
are used throughout the rest of AEON.

#+BEGIN_SRC emacs-lisp :noweb-ref bootstrap-aeon
  <<core-emacs-configuration>>
  <<load-bootstrap-packages>>
#+END_SRC

** Core Appearance and Usability
When setting up some of the core configuration of AEON, we start by disabling
some features in Emacs which are enabled by default, and then enable UTF-8
support. Next we configure the embedded lisp interpreter to fit better with
modern hardware.

#+BEGIN_SRC emacs-lisp :noweb-ref core-emacs-configuration
  <<disable-unnecessary-default-features>>
  <<enable-utf8-support>>
  <<configure-elisp-interpreter>>
#+END_SRC
*** Disable Unnecessary Features
Emacs comes filled with some features which are simply unneccessary for most
people's workflows, many of which are just plain ugly. All of these features are
disabled here. If someone really wants to use them, they can enable them again
in their own config at a later date.

#+BEGIN_SRC emacs-lisp :noweb-ref disable-unnecessary-default-features
  (when (functionp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (functionp 'menu-bar-mode)
    (menu-bar-mode -1))
  (when (functionp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (when (functionp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
  (when (functionp 'mouse-wheel-mode)
    (mouse-wheel-mode -1))
  (when (functionp 'tooltip-mode)
    (tooltip-mode -1))
  (when (functionp 'blink-cursor-mode)
    (blink-cursor-mode -1))

  (setq ring-bell-function (lambda ())
        inhibit-startup-screen t
        frame-resize-pixelwise t)
#+END_SRC
*** Enable UTF-8 Support
Emacs is a very old text editor, and doesn't come with UTF-8 support
pre-enabled.  UTF-8 is rather important to modern file editing however, so AEON
enables it by default.

#+BEGIN_SRC emacs-lisp :noweb-ref enable-utf8-support
  (set-charset-priority 'unicode)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+END_SRC
*** Configure the Emacs Lisp Interpreter
The emacs lisp interpreter has many default settings which are out of date for
modern computers.  The garbage collector doesn't need to be run as often as the
default, the message buffer can have a lot more messages in it, and cl features
should be loaded.

#+BEGIN_SRC emacs-lisp :noweb-ref configure-elisp-interpreter
  (require 'cl-lib)

  (setq message-log-max 16384
        gc-cons-threshold (* 50 1024 1024)
        jit-lock-stealth-time 1
        jit-lock-stealth-verbose nil)
#+END_SRC
** Load Bootstrap Packages
In order to bootstrap AEON fully, we need the package manager fully configured.
A small amount of configuration happens before this config is loaded, in which
straight.el is installed and then is used to get the latest version of org,
which is then used to load this config. However, throughout the rest of this
config and in any modules, the desired interface is to use use-package, so that
will be loaded first, to make loading the other packages for bootstrapping
consistent.

#+BEGIN_SRC emacs-lisp :noweb-ref load-bootstrap-packages
  <<use-package-configuration>>
#+END_SRC
*** Use-package Installation and Configuration
straight.el is the package manager used by AEON, but use-package provides a
great interface to many package managers, and is familiar to many Emacs users,
so it will be installed here to be used as the primary way of loading packages
in AEON, at least under the hood.

First AEON installs use-package, then we configure use-package to always use
straight.el by default.
#+BEGIN_SRC emacs-lisp :noweb-ref use-package-configuration
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+END_SRC


* Modules
:PROPERTIES:
:header-args: :noweb no-export :tangle no
:END:
Modules are the units of configuration in AEON. They are used to declare
packages which should be installed into the emacs distrobution, they create
initialization code to setup the initial state needed for those packages, they
configure those packages once loaded, and finally they may declare additional
functionality which can be used to interact with those packages without
modifying them.

** Packages
Packages are loaded with straight.el to allow for proper handling of
installation and modifications of packages that become necessary, as well as
configuration. A package can be declared as a depencency for multiple modules,
and each module can define its own set of initialization and configuration
steps.  It is undefined behavior for multiple modules to configure the same
thing, unless a configuration module is present which overrides both.

** Configuration Modules
Configuration Modules are special modules which generally do not declare any
package dependencies.  They however do declare dependencies on multiple modules,
and upon being loaded will override any functionality which would have been
conflicting between the two other modules. This allows for a single place to
resolve conflicts between multiple configurations.

** Loading Modules
For now, loading a module is a simple task, because the module format hasn't
been defined yet. That means right now the only tasks which must take place are
to find the module, tangle the org file, compile the elisp, and load the
compiled files.

#+BEGIN_SRC emacs-lisp :noweb-ref bootstrap-module-loading
  (defun aeon/load-module (module-name)
    "Loads a module of the given name from \"emacs-home/modules/module-name/\".

  This includes checking if there has been an update to the org files since the last time
  the elisp had been tangled, tangling it if so, compiling it, and then loading it."
    (interactive "sName of the module you wish to load: ")
    (let ((module-directory
           <<get-module-directory>>
           ))
      (if (file-directory-p module-directory)
        (let ((elisp-files (directory-files-recursively module-directory
                                                        ".*\\.elc$"))

              (org-files (directory-files-recursively module-directory
                                                      ".*\\.org$")))
          (if (< (length org-files) 1)
              (message "No files found in the module. Time to write some code!")
            <<tangle-and-load-module-elisp>>
            ))
        (message "Not a valid module name."))))
#+END_SRC

*** Get the Module's Directory
The directory for a module is generated as a concatonation of the user's emacs
directory, the name for the module directory, and the name of the module which
is being loaded. Together, that may look something like so:
=~/.emacs.d/modules/module-name/=

#+BEGIN_SRC emacs-lisp :noweb-ref get-module-directory
  (string-join (list user-emacs-directory
                     "modules"
                     module-name
                     "")
               "/")
#+END_SRC

*** Load the Module's Emacs Lisp Code
Once a module's files have been found, we need to load them. To do so, we first
need to tangle the elisp and compile them into =.elc= files, and then we load
them.

#+BEGIN_SRC emacs-lisp :noweb-ref tangle-and-load-module-elisp
  (let ((elc-files ()))
    <<tangle-elisp-and-push-to-elc-files>>
    <<load-elc-files>>
    )
#+END_SRC

**** Tangle Emacs Lisp Files
When we tangle the elisp files and compile them to =.elc= files, it can be
somewhat resource intensive. Instead of always performing that step, we can
check to see if the org files have more recent changes than the compiled lisp,
and if they do, then we will tangle and compile them. Otherwise, we can simply
pretend that we compiled them, and push the old elisp into the list.

#+BEGIN_SRC emacs-lisp :noweb-ref tangle-elisp-and-push-to-elc-files
  (if
      <<org-files-are-newer-than-elisp>>
      <<tangle-and-compile-org-files--push-compiled-file-names-to-elc-files>>
    <<push-existing-elisp-files-to-elc-files>>
    )
#+END_SRC

***** Checking if Org files are newer than their matching Emacs Lisp
To check if the org files are newer, we make use of the CL library for emacs,
which allows us the use of the excellent ~some~ function. For each org file, it
checks to see if there exists an emacs lisp file which is newer than itself. If
so, the whole thing short-circuits and returns ~t~.

#+BEGIN_SRC emacs-lisp :noweb-ref org-files-are-newer-than-elisp
  (cl-some (lambda (org-file)
             (cl-some (lambda (elisp-file)
                        (file-newer-than-file-p
                         org-file
                         elisp-file))
                      elisp-files))
           org-files)
#+END_SRC

***** Tangling and Compiling the Org Files
To tangle and compile the org files, we loop through each org file and call the
elisp function ~org-babel-tangle-file~ on it. That will return a list of the
emacs lisp files which have been tangled from it. We then loop over each file
which was tangled from the module and compile it, pushing the name of the
compiled file into the variable ~elc-files~. Since the elisp files are transient
and are not intended to be evaluated directly, we remove them right after
compiling them.

#+BEGIN_SRC emacs-lisp :noweb-ref tangle-and-compile-org-files--push-compiled-file-names-to-elc-files
  (dolist (org-file org-files)
    (dolist (elisp-file (org-babel-tangle-file org-file))
      (byte-compile-file elisp-file)
      (push (string-join (list elisp-file "c")) elc-files)
      (delete-file elisp-file)))
#+END_SRC

***** Push Existing Emacs Lisp Files to ~elc-files~
If the elisp files are newer than the org ones, they don't need to be
re-compiled, so as a result we just add the already-existing elisp files to the
list.

#+BEGIN_SRC emacs-lisp :noweb-ref push-existing-elisp-files-to-elc-files
  (dolist (file elisp-files)
    (push file elc-files))
#+END_SRC

**** Load Emacs Lisp Files
Once all the files have been pushed into the list, we can go through each of
them and load them into emacs.

#+BEGIN_SRC emacs-lisp :noweb-ref load-elc-files
  (dolist (elc-file elc-files)
    (load-file elc-file))
#+END_SRC



* Load Emacs Custom File
Emacs includes a way to customize large portions of the behaviors that come
default from within itself, handled from within the custom file.  Any changes
that the user makes through the customize interface will be saved to the custom
file, and the configuration has the option to load that file.  Emacs' default
behavior is to append all custom information to the end of the init.el file,
however since this is a literate config, that is less than desireable. Instead
we will set a specific file to be used, and load it if it exists.
#+BEGIN_SRC emacs-lisp :noweb-ref load-emacs-custom-file
  (setq custom-file (expand-file-name ".custom.el" user-emacs-directory))

  (when (file-exists-p custom-file)
    (load-file custom-file))
#+END_SRC
